#Requires waitress, flask, opencv-python

# Import necessary modules
from flask import Flask, Response, abort
from waitress import serve
import cv2
import threading
import time
import math
import numpy as np


# Set the desired frames per second for the video stream
# Reccomend a divisor of the framerate of the rtsp stream
videoFPS = 2

# Set the maximum amount of time to wait for a client request before stopping the RTSP stream
timeout = 300

# Set the level of JPEG compression to use on the frames
compression = 35

# Set whether to resize the frames before sending them to the client
resize = False

# If resizing, set the desired frame size
framesize = (640, 360)

# Set the list of RTSP camera URLs to use
cameras = [
    "rtsp://<IP_ADDR>/ch0_1.h264",
    "rtsp://<IP_ADDR>/ch0_1.h264",
    "rtsp://<IP_ADDR>/ch0_1.h264",
    "rtsp://<IP_ADDR>/ch0_1.h264",
    "rtsp://<IP_ADDR>/ch0_1.h264",
    "rtsp://<IP_ADDR>/ch0_1.h264",
]


class RTSP_capture:

    compression = None
    resize = None
    framesize = None
    timeout = None
    camera = None
    targetFPS = None

    streaming = False
    lastFrame = None
    capture = None
    lastRequest = 0
    frameRate = 0
    jumpFrame = 0


    def __init__(self, camera, compression = 50, resize = False, framesize = (640, 360), timeout = 300, targetFPS = 4):
        self.compression = compression
        self.resize = resize
        self.framesize = framesize
        self.timeout = timeout
        self.camera = camera
        self.targetFPS = targetFPS
        
        self.resetFrameBuffer()
    

    def resetFrameBuffer(self):
        # Generate placeholder frame and encode it as jpeg
        placeholder = np.zeros((360, 640, 3), dtype = np.uint8)
        self.lastFrame = cv2.imencode('.jpg', placeholder, [cv2.IMWRITE_JPEG_QUALITY, 0])[1]

    
    def endStreaming(self):
        self.streaming = False
        self.capture = None
        self.resetFrameBuffer()
    
    
    def startStreaming(self):
        self.streaming = True
        self.capture = cv2.VideoCapture(self.camera)
        self.frameRate = self.capture.get(cv2.CAP_PROP_FPS)
        self.jumpFrame = math.ceil((self.frameRate / self.targetFPS) - 1)


    def updateFrameLoop(self):

        self.startStreaming()

        while self.lastRequest + self.timeout > time.time() or self.timeout == 0:
            try:
                self.updateFrame()
            except Exception as e:
                # If for some reason the RTSP stream gets interrupted it resets
                # For example wifi cameras tends to lose packets randomly
                self.startStreaming()

        self.endStreaming()


    def updateFrame(self):
        for x in range(self.jumpFrame):
            self.capture.grab()

        success, frame = self.capture.read()

        if success:
            if self.resize:
                frame = cv2.resize(frame, self.framesize)

            self.lastFrame = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, self.compression])[1]
        else:
            self.startStreaming()


    def readFrame(self):
        if self.streaming == False:
            threading.Thread(target=self.updateFrameLoop).start()

        self.lastRequest = time.time()
        return self.lastFrame.tobytes()



videoOBJ = []
app = Flask(__name__)

@app.route('/camera/<cameraID>')
def index(cameraID):
    # Check if the "cameraID" parameter is a valid integer
    if cameraID.isdigit() and int(cameraID) < len(videoOBJ):
        # If the "cameraID" parameter is valid, return a multipart response containing a dynamically generated MJPEG streaming
        # The streaming is generated by calling the gen() function, which takes the "cameraID" and the desired frame rate as arguments
        return Response(gen(int(cameraID), videoFPS), mimetype='multipart/x-mixed-replace; boundary=frame')
    else:
        # If the "cameraID" parameter is not a valid integer, return an HTTP 404 error
        abort(404)

# Define the gen() function that generates the MJPEG streaming
# The function takes the "cameraID" and the desired frame rate as arguments
def gen(cameraID, framerate):
    timeNow = time.time()
    while True:
        while (time.time() < timeNow + 1 / framerate):
            time.sleep(0.05)
        
        jpeg = videoOBJ[cameraID].readFrame()
        timeNow = time.time()
        yield (b'--frame\r\n' b'Content-Type: image/jpeg\r\n\r\n' + jpeg + b'\r\n')


# Run the app
if __name__ == '__main__':
    for i in range(len(cameras)):
        videoOBJ.append(RTSP_capture(cameras[i], compression, resize, framesize, timeout, videoFPS))

    #Development server
    #app.run(host="0.0.0.0", threaded=True)

    #Production server using Waitress
    serve(app, host='0.0.0.0', port=5000, threads=64)